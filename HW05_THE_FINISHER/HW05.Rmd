---
title: "HW05_THE_FINISHER"
author: "Chad Fibke"
date: '2017-10-11'
output: github_document
---

# 1.Installation of data set and data analysis packages 

```{r}
library(gapminder)
library(tidyverse)
library(forcats)
library(cowplot) #For plot manipulations
library(RColorBrewer) # To add a little color to this party

```
Just some quick notes:

+ Comments about my code will be within code chunks:
```{r}
# Like this 
```
+ Comments about my workflow will be outside of the code chunks. 
+ I will be working with the gapminder dataset!

# 2.Factor management 
Let's take a look at gapminder to see what variables are considered factors:
```{r}
str(gapminder)
```

Now we know gapminder's variable:

+ Country is a factor and  has 142 different levels.

```{r Country.levels, echo=TRUE}
levels(gapminder$country) %>% 
  head() %>% 
  knitr::kable(col.names = "Country Factors")# I'm only showing few levels to help our poor eyes
```

+ Continent is a factor and has 5 different levels. 
```{r Continent.levels, echo=TRUE}
levels(gapminder$continent) %>% 
  knitr::kable( col.names = "Continent Factors")

```
We now know what factors we are working with!

We want to drop Oceania, but **what** we are actually dropping:

```{r}
 EX.Oceania <- gapminder %>% 
  filter(continent == "Oceania") 
 
EX.Oceania$country %>%   
   fct_drop() %>% 
  levels() 

EX.Oceania$continent %>%   
   fct_drop() %>% 
  nlevels() 
```
The above shows that when we drop the Oceania Continent: 

+ One level will be dropped from continents.
+ Two levels will be dropped from countries.

Now we know how many we are dropping...... so I'm now going to drop them:

```{r}
Dropped.Oceania <- gapminder %>% 
  filter(continent != "Oceania") %>% 
  droplevels()# droplevels was used because it can be applied to a dataset, whereas fct_drop  is applied to a vector. 

Dropped.Oceania$country %>%
  nlevels()# As seen above we have officially dropped the "Australia" and "New Zealand" levels, leaving us with 140 country levels.

Dropped.Oceania$continent %>%
  levels()# As seen above we have officially dropped the Oceania level, leaving us with only 4 remaining continent levels.

```

We have officially Dropped Oceania!


We can now wrangle this data so we can focus on the concept of reordering:

```{r Original.plot, echo=TRUE}
THE.AMERICAS <- Dropped.Oceania %>%
  filter(continent == "Americas") %>% 
  select(continent, country, year, pop) %>%
  group_by(country) %>%
  mutate(maxPop = max(pop)) %>%
  ungroup() %>%  # We cannot reorder factors if the data frame is grouped.
  droplevels()
# this is just cleaning up some data to calculate the max population size in the Americas!
 


MaxPOP.Original<-THE.AMERICAS  %>%  
 ggplot(aes(x = country, y = maxPop))+
  geom_point()+
    ggtitle(" Max Population size \n for countries within the Americas ")+
  xlab("")+
    theme(axis.text.x = element_text(angle = 90),
          axis.text = element_text(size = 10)) # I'm assigning this plot because I'll be using it later.


MaxPOP.Original
 
```

We can see that the default alphabetically orders the countries.

What if we take the same data set and use arrange to move the countries around, and see what happens when we plot it:

```{r Arranged.plot, echo=TRUE}
MaxPOP.Arranged <-THE.AMERICAS %>% 
  arrange(maxPop) 

knitr::kable(head(MaxPOP.Arranged))
#This is just to show that the data is arranged properly!


Arranged.plot <- MaxPOP.Arranged %>% 
  ggplot(aes(x = country, y = maxPop))+
  geom_point(color = "red")+
    ggtitle(" Max Population size \n for countries within the Americas ")+
  xlab("")+
    theme(axis.text.x = element_text(angle = 90),
          axis.text = element_text(size = 10))

Arranged.plot
```

Arranging the data, based on the max population size, does not have the ability to override the default alphabetical ordering when it comes to graphing. 


Now lets try to reorder these countries using forcats!:


```{r reordered.plot, echo=TRUE}
Ordered.AMERICAS <- THE.AMERICAS %>% 
  mutate(country = fct_reorder(country, maxPop))


reordered.plot<- Ordered.AMERICAS%>%  
 ggplot(aes(x = country, y = pop))+
  geom_boxplot()+
     theme(axis.text.x = element_text(angle = 90),
             axis.text = element_text(size = 10))+
  ggtitle("Population size distributions for the Americas ")+
  xlab("")+
  ylab("Population Size")+
   geom_rect(aes(xmin = 12, xmax = 16, ymin = 1, ymax = 11^7), alpha = 0.0001, color = "red")

reordered.plot <- ggdraw(reordered.plot)  + 
  draw_label("TOO MANY!", angle = 45, size = 50, alpha = .2)
reordered.plot

```

I chose box plots because their upper whiskers are sensitive to large outlier (max population values). The red box shows this ordering is specific to the max observation **and** ignores medians. This plot also shows:

+ That reordering a factor, by another quantitative measure, can help order it within a table or plot!
+ Too Many refers to a lot of countries have similar populations distributions, which we will correct for later!


lets try to mess up the reordered data with arranging the data in descending order


```{r Mix.plot, echo= TRUE}
Mixed<- Ordered.AMERICAS %>% 
  arrange(desc(maxPop)) 

Mixed%>%
  head() %>% 
  knitr::kable()
#This is just to show that the data is arranged properly!
  
  
  Mix.plot <- Mixed %>% 
ggplot(aes(x = country, y = pop))+
  geom_boxplot()+
     theme(axis.text.x = element_text(angle = 90),
             axis.text = element_text(size = 10))+
  ggtitle("Population size ditributions for the Americas ")+
  xlab("")+
  ylab("Population Size")
  
  
Mix.plot

```

This shows that using arrange will only effect the ordering within a table, and cannot override the factor order within a plot.


 I'm going to show the use of fct_collapse to rename **AND** lump at the same time. As we saw above, a lot of countries have similar population distributions, so I'm going to call them "other":


```{r easy.to.read.plot, echo= TRUE}
Collapsed.Americas <- Ordered.AMERICAS %>% 
  mutate(country =fct_collapse (Ordered.AMERICAS$country, Other = c("Trinidad and Tobago", "Jamaica", "Panama", "Uruguay", "Puerto Rico", "Costa Rica", "Nicaragua", "Paraguay", "El Salvador", "Honduras", "Haiti", "Bolivia", "Dominican Republic", "Cuba", "Guatemala","Ecuador", "Chile", "Venezuela", "Peru", "Canada", "Argentina", "Colombia" ),
  Mexico ="Mexico",
  Brazil ="Brazil",
  USA = "United States")) %>% 
  droplevels()

 easy.to.read <- Collapsed.Americas %>% 
 ggplot(aes(x = country, y = pop))+  # I already re-ordered above!
  geom_boxplot(aes(fill = country))+
   theme_classic()+
  ggtitle("Population size distributions for the Americas ")+
  xlab("")+
  ylab("Population Size")+
   scale_fill_manual(values=brewer.pal(n=4, "RdGy"))
  easy.to.read
```


Below, I’ve use cow plots to show the difference that fct_collapse made by comparing 2 graphs:

```{r Comparing.plots, echo = TRUE, fig.width=10,fig.height=11}
plot_grid(reordered.plot, easy.to.read, labels = c("A", "B"), nrow = 2, align = "v")

```

 
# 3.Common part &File I/O 

Lets continue our adventure with the Collapsed.Americas dataset, and make sure the factors have been managed properly before we start saving:

```{r Americas.country.factors, echo= TRUE}

Collapsed.Americas$country %>%
  levels() %>% 
  knitr::kable( col.names = "Country Factors")# This is just to remind you what is in Collapsed.Americas

```

We have finished some analysis for the day (what we have done above) and decide the save our data:
```{r}
write_csv(Collapsed.Americas, "Collapsed.Americas.csv")
```


Boom, saved! We no longer have to worry about losing our data! (I cannot remove this dataset because Knitr has given me an error saying that this object doesn’t exist when I use it in later code)



I'm now going to load this Csv file and see if our factors are still safe:
```{r Collapsed.Americas.CSV, echo= TRUE}
Collapsed.Americas.CSV <- read_csv("Collapsed.Americas.csv")

knitr::kable(head(Collapsed.Americas.CSV))

```
wait a second..... all my factor variables are seen as charactor variables. Let me fix that and continue so see if my variables are still ordered:

```{r HOW.csv.boring, echo= TRUE}
Collapsed.Americas.CSV %>% 
  mutate(country = factor(country), continent = factor(continent)) %>% 
  knitr::kable()

 Collapsed.Americas.CSV %>%  
 ggplot(aes(x =country, y = pop))+
  geom_boxplot(aes(fill = country))+
   theme_classic()+
  ggtitle("Population size distributions for the Americas ")+
  xlab("")+
  ylab("Population Size")+
   scale_fill_manual(values=brewer.pal(n=4, "Greys"))
   

```

The above plot shows how "boring" using the write_csv()/read_csv() is because:

+ The factor names were kept, but this is also one of the strengths of fct_collapse.
+ The factor order, based of max population size, was **not** kept!


OR we can import/export using dput/dget instead!
```{r HOW.RED.HOT.RGET.is, echo= TRUE}
dput(Collapsed.Americas, "Collapsed.Americas-dput.txt")

Collapsed.Americas_dget <- dget("Collapsed.Americas-dput.txt") 


Collapsed.Americas_dget %>% 
  knitr::kable()

   
Collapsed.Americas_dget %>% 
  ggplot(aes(x =country, y = pop))+
  geom_boxplot(aes(fill = country))+
   theme_classic()+
  ggtitle("Population size ditributions for the Americas ")+
  xlab("Countries")+
  ylab("Population Size")+
   scale_fill_manual(values=brewer.pal(n=4, "Reds"))


```


The above plot shows how "red hot" using dput/dget is because:

+ The factor names were kept (due to fct_collapse)
+ The factor order based of max population size was kept!






